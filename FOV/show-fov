#!/usr/bin/env perl
#
# Field of View (FOV) via raycast

use 5.24.0;
use warnings;
use Data::Dumper;
use Math::Trig qw(:pi deg2rad rad2deg);
use lib '.';
use Misc;

our $MAX_X = 78;
our $MAX_Y = 23;

package Line {
    use integer;
    # Bresenham. probably from Rosetta Code. callback with abort is
    # typically more efficient than going through the list of points,
    # especially where the FOV is blocked lots
    sub map_line {
        my ($x0, $y0, $x1, $y1, $cb) = @_;
        my $dx        = abs $x1 - $x0;
        my $sx        = $x0 < $x1 ? 1 : -1;
        my $dy        = abs $y1 - $y0;
        my $sy        = $y0 < $y1 ? 1 : -1;
        my $err       = ($dx > $dy ? $dx : -$dy) / 2;
        my $not_first = 0;
        while (1) {
            last if $x0 < 0 or $x0 >= $MAX_X or $y0 < 0 or $y0 >= $MAX_Y;
            if ($not_first++) {
                last if $cb->($x0, $y0) == -1;
            }
            last if $x0 == $x1 and $y0 == $y1;
            my $e2 = $err;
            if ($e2 > -$dx) {
                $err -= $dy;
                $x0  += $sx;
            }
            if ($e2 < $dy) {
                $err += $dx;
                $y0  += $sy;
            }
        }
    }
}

# center
my $x = 60;
my $y = 12;

*STDOUT->autoflush(1);
print clear_screen, t_norm;

# some random fill in a map to restrict FOV with
my @map;
for my $r (0 .. 23) {
    for my $c (0 .. 40) {
        my $ch = rand() > 0.5 ? '#' : '.';
        $map[$r][$c] = $ch;
        $map[$r][ $c + 40 ] = $ch;
    }
}

open my $fh, '>', 'log' or die "could not write 'log': $!\n";
$fh->autoflush(1);
sub logit { say $fh "@_" }

# radius => div (via `raycast` encircle calculation)
my $div    = 64;
my $radius = 7;

print at($x, $y), '@';
my @points = ring_points($radius, pi2 / $div, $x, $y);
while (my ($px, $py) = splice @points, 0, 2) {
    Line::map_line(
        $x, $y, $px, $py,
        sub {
            my ($lx, $ly) = @_;
            my $ch = $map[$ly][$lx];
            print at($lx, $ly), $ch;
            return -1 if $ch eq '#';
        }
    );
}

$x = 20;
print at($x, $y), '@';
@points = ring_points($radius, pi2 / $div, $x, $y);
while (my ($px, $py) = splice @points, 0, 2) {
    Line::map_line(
        $x, $y, $px, $py,
        sub {
            my ($lx, $ly) = @_;
            my $ch = $map[$ly][$lx];
            print at($lx, $ly), $ch;
        }
    );
}

print at(0, $MAX_Y);

