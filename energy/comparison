#!/usr/bin/env perl
#
# attempt to compare different energy systems using a more or less level
# playing field (or the Procrustean wedging of them into a turn-based
# bed). the energy systems are:
#
#  1. cost-based. each animate moves when its cost returns to 0; that
#     move adds some value to the cost. each turn the minimum cost is
#     removed from each animate
#  2. circular buffer. animates to move are inserted as appropriate
#     somewhere into a circular buffer, with the caveat that without
#     additional complications no move can be scheduled beyond what the
#     buffer can hold (the others do not have this restriction)
#  3. priority queue. a standard priority queue algorithm is used to
#     schedule events. a turn-based epoch prevents actions with a low
#     priority from forever drowning out longer events from happening
#  4. grouping priority queue. events that happen at the same time are
#     returned in a single set
#
# note that some methods do not allow or would require complications to
# speed up or slow down an animate; that is, an animate moves, then
# somewhere before its next move something hits it with a slowing spell,
# or, worse, a speed up spell

use 5.24.0;
use warnings;
use Benchmark qw(cmpthese);
use List::GroupingPriorityQueue;
use List::Util qw(min shuffle);
use Queue::Priority;

package Animate {
    use Moo;
    has qw(name is ro);
    has qw(cost is rw);
    use overload
      '""'  => sub { $_[0]->name },
      '<=>' => sub { $_[0]->cost <=> $_[1]->cost };
}

sub make_cbuf {
    my ( $size ) = @_;
    my @buf;
    my $cur = 0;
    return (
        sub {
            my $ret = $buf[$cur];
            $buf[ $cur++ ] = undef;
            $cur %= $size;
            return $ret;
        },
        sub {
            my ( $offset, @events ) = @_;
            push $buf[ ( $cur + $offset - 1 ) % $size ]->@*, @events;
        },
    );
}

sub make_animates {
    my ( %args ) = @_;
    [ map Animate->new( name => $_, cost => $args{cost} ), 1 .. $args{count} ]
}

sub run_cost {
    my ( $animates, $moves, $costfn ) = @_;
    my $turn = 0;
    while ( $moves > 0 ) {
        my $min = min map $_->cost, $animates->@*;
        $turn += $min;
        my @todo;
        for my $ani ( $animates->@* ) {
            my $when = $ani->cost - $min;
            if ( $when <= 0 ) {
                push @todo, $ani;
            } else {
                $ani->cost($when);
            }
        }
        for my $ani ( shuffle @todo ) {
            $ani->cost( $costfn->() );
            $moves--;
        }
    }
}

sub run_cbuf {
    my ( $bufsize, $animates, $moves, $costfn ) = @_;
    my ( $active, $insert ) = make_cbuf( $bufsize );
    for my $ani ( $animates->@* ) {
        $insert->( 1, $ani );
    }
    my $turn = 0;
  TURN: while ( $moves > 0 ) {
        $turn++;
        my $todo = $active->() // next TURN;
        for my $ani ( shuffle $todo->@* ) {
            $insert->( $costfn->(), $ani );
            $moves--;
        }
    }
}

sub run_lgpq {
    my ( $animates, $moves, $costfn ) = @_;
    # use OO interface so not comparing the slOOw method calls of
    # Queue::Priority with fast grpriq_add function calls
    my $q = List::GroupingPriorityQueue->new;
    for my $ani ( $animates->@* ) {
        $q->insert( $ani, $ani->cost );
    }
    my $turn = 0;
    while ( $moves > 0 ) {
        my $aniturn = $q->min;
        $turn = $aniturn->[1];
        for my $ani ( shuffle $aniturn->[0]->@* ) {
            my $newcost = $turn + $costfn->();
            $ani->cost( $newcost );
            $q->insert( $ani, $newcost );
            $moves--;
        }
    }
}

sub run_priq {
    my ( $animates, $moves, $costfn ) = @_;
    my $q = Queue::Priority->new( scalar $animates->@* );
    for my $ani ( $animates->@* ) {
        $q->insert($ani);
    }
    my $turn = 0;
    while ( $moves > 0 ) {
        my @todo = $q->remove;
        $turn = $todo[0]->cost;
        push @todo, $q->remove while !$q->is_empty and $q->peek->cost == $turn;
        for my $ani ( shuffle @todo ) {
            $ani->cost( $turn + $costfn->() );
            $q->insert( $ani );
            $moves--;
        }
    }
}

sub compare {
    my ( %args ) = @_;
    cmpthese(
        $args{iters},
        {   cost => sub {
                run_cost( make_animates( count => $args{ani_count}, cost => 0 ), $args{moves}, $args{costfn} );
            },
            cbuf => sub {
                run_cbuf( $args{bufsize}, make_animates( count => $args{ani_count}, cost => 0 ),
                    $args{moves}, $args{costfn} );
            },
            lgpq => sub {
                run_lgpq( make_animates( count => $args{ani_count}, cost => 1 ), $args{moves}, $args{costfn} );
            },
            priq => sub {
                run_priq( make_animates( count => $args{ani_count}, cost => 1 ), $args{moves}, $args{costfn} );
            },
        }
    );
}

sub rand_re { 1 + int rand 2 }
sub rand_bi { 1 + int rand 8 }

# see Benchmark perldocs for what the "iters" key means. bufsize is
# for the circular buffer and must be at least as large as what the
# costfn returns
compare(
    iters     => -10,
    ani_count => 100,
    moves     => 1000,
    costfn    => \&rand_bi,
    bufsize   => 8
);
